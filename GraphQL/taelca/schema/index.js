const { makeExecutableSchema, addMockFunctionsToSchema  } = require ('graphql-tools')
const resolvers = require('../resolvers')
const Usuario = require('./Usuario')
const casual = require('casual')


const rootQuery = `

type Link {
    id: ID!
    url: String!
    description: String!
  }

  type Query{
    usuarios: [Usuario]
    usuario(id: Int): Usuario
    allLinks: [Link!]!
  }

type Mutation{
  usuarioAdd(usuario: NuevoUsuario): Usuario
  usuarioEdit(usuarioid: Int!, usuario: UsuarioEditable): Usuario
  usuarioDelete(usuarioid: Int): Usuario
  createLink(url: String!, description: String!): Link
  # Note that this mutation could receive the email and password directly
  # as arguments, with no problem. You're just using this "authProvider"
  # instead to mimic the signature generated by Graphcool, which will
  # make it easier to integrate this server implementation later with the
  # code from the frontend tutorials.
  register(nombre: String!, email: String!, password: String!): Usuario
  login(email: String!, password:String!): String!

}


`
const schema = makeExecutableSchema({
  typeDefs: [rootQuery, Usuario],
  resolvers
})

addMockFunctionsToSchema ({
   schema,
   mocks:{
     Usuario: ()=>{
       return{
         id: casual.uuid,
         nombre: casual.name
       }
     }
   },
   preserveResolvers:true
})


module.exports = schema
